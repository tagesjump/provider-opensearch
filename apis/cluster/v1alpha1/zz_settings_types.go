// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type SettingsInitParameters struct {

	// (String) Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	// Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	ActionAutoCreateIndex *string `json:"actionAutoCreateIndex,omitempty" tf:"action_auto_create_index,omitempty"`

	// (Boolean) When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	// When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	ActionDestructiveRequiresName *bool `json:"actionDestructiveRequiresName,omitempty" tf:"action_destructive_requires_name,omitempty"`

	// (Boolean) Make the whole cluster read only and metadata is not allowed to be modified
	// Make the whole cluster read only and metadata is not allowed to be modified
	ClusterBlocksReadOnly *bool `json:"clusterBlocksReadOnly,omitempty" tf:"cluster_blocks_read_only,omitempty"`

	// (Boolean) Make the whole cluster read only, but allows to delete indices to free up resources
	// Make the whole cluster read only, but allows to delete indices to free up resources
	ClusterBlocksReadOnlyAllowDelete *bool `json:"clusterBlocksReadOnlyAllowDelete,omitempty" tf:"cluster_blocks_read_only_allow_delete,omitempty"`

	// (Boolean) If false, you cannot close open indices
	// If false, you cannot close open indices
	ClusterIndicesCloseEnable *bool `json:"clusterIndicesCloseEnable,omitempty" tf:"cluster_indices_close_enable,omitempty"`

	// (String) A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	// A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	ClusterInfoUpdateInterval *string `json:"clusterInfoUpdateInterval,omitempty" tf:"cluster_info_update_interval,omitempty"`

	// frozen data nodes; shards for closed indices do not count toward this limit
	// The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
	ClusterMaxShardsPerNode *float64 `json:"clusterMaxShardsPerNode,omitempty" tf:"cluster_max_shards_per_node,omitempty"`

	// (Number) The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	// The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	ClusterMaxShardsPerNodeFrozen *float64 `json:"clusterMaxShardsPerNodeFrozen,omitempty" tf:"cluster_max_shards_per_node_frozen,omitempty"`

	// (String) Specifies which operations are rejected when there is no active master in a cluster (all, write)
	// Specifies which operations are rejected when there is no active master in a cluster (all, write)
	ClusterNoMasterBlock *string `json:"clusterNoMasterBlock,omitempty" tf:"cluster_no_master_block,omitempty"`

	// (String) Whether allocation for persistent tasks is active (all, none)
	// Whether allocation for persistent tasks is active (all, none)
	ClusterPersistentTasksAllocationEnable *string `json:"clusterPersistentTasksAllocationEnable,omitempty" tf:"cluster_persistent_tasks_allocation_enable,omitempty"`

	// (String) A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	// A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	ClusterPersistentTasksAllocationRecheckInterval *string `json:"clusterPersistentTasksAllocationRecheckInterval,omitempty" tf:"cluster_persistent_tasks_allocation_recheck_interval,omitempty"`

	// (String) Specify when shard rebalancing is allowed (always, indices_primaries_active, indices_all_active)
	// Specify when shard rebalancing is allowed (always, indices_primaries_active, indices_all_active)
	ClusterRoutingAllocationAllowRebalance *string `json:"clusterRoutingAllocationAllowRebalance,omitempty" tf:"cluster_routing_allocation_allow_rebalance,omitempty"`

	// (String) Use custom node attributes to take hardware configuration into account when allocating shards
	// Use custom node attributes to take hardware configuration into account when allocating shards
	ClusterRoutingAllocationAwarenessAttributes *string `json:"clusterRoutingAllocationAwarenessAttributes,omitempty" tf:"cluster_routing_allocation_awareness_attributes,omitempty"`

	// (Number) Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	// Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	ClusterRoutingAllocationBalanceIndex *float64 `json:"clusterRoutingAllocationBalanceIndex,omitempty" tf:"cluster_routing_allocation_balance_index,omitempty"`

	// (Number) Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	// Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	ClusterRoutingAllocationBalanceShard *float64 `json:"clusterRoutingAllocationBalanceShard,omitempty" tf:"cluster_routing_allocation_balance_shard,omitempty"`

	// (Number) Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	// Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	ClusterRoutingAllocationBalanceThreshold *float64 `json:"clusterRoutingAllocationBalanceThreshold,omitempty" tf:"cluster_routing_allocation_balance_threshold,omitempty"`

	// (Number) How many concurrent shard rebalances are allowed cluster wide
	// How many concurrent shard rebalances are allowed cluster wide
	ClusterRoutingAllocationClusterConcurrentRebalance *float64 `json:"clusterRoutingAllocationClusterConcurrentRebalance,omitempty" tf:"cluster_routing_allocation_cluster_concurrent_rebalance,omitempty"`

	// (Boolean) Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	// Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	ClusterRoutingAllocationDiskIncludeRelocations *bool `json:"clusterRoutingAllocationDiskIncludeRelocations,omitempty" tf:"cluster_routing_allocation_disk_include_relocations,omitempty"`

	// (Boolean) Whether the disk allocation decider is active
	// Whether the disk allocation decider is active
	ClusterRoutingAllocationDiskThresholdEnabled *bool `json:"clusterRoutingAllocationDiskThresholdEnabled,omitempty" tf:"cluster_routing_allocation_disk_threshold_enabled,omitempty"`

	// (String) Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	// Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	ClusterRoutingAllocationDiskWatermarkHigh *string `json:"clusterRoutingAllocationDiskWatermarkHigh,omitempty" tf:"cluster_routing_allocation_disk_watermark_high,omitempty"`

	// (String) Allocator will not allocate shards to nodes that have more than this percentage disk used
	// Allocator will not allocate shards to nodes that have more than this percentage disk used
	ClusterRoutingAllocationDiskWatermarkLow *string `json:"clusterRoutingAllocationDiskWatermarkLow,omitempty" tf:"cluster_routing_allocation_disk_watermark_low,omitempty"`

	// (String) Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	// Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	ClusterRoutingAllocationEnable *string `json:"clusterRoutingAllocationEnable,omitempty" tf:"cluster_routing_allocation_enable,omitempty"`

	// (Number) How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	// How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentIncomingRecoveries *float64 `json:"clusterRoutingAllocationNodeConcurrentIncomingRecoveries,omitempty" tf:"cluster_routing_allocation_node_concurrent_incoming_recoveries,omitempty"`

	// (Number) How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	// How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries *float64 `json:"clusterRoutingAllocationNodeConcurrentOutgoingRecoveries,omitempty" tf:"cluster_routing_allocation_node_concurrent_outgoing_recoveries,omitempty"`

	// (Number) A shortcut to set both incoming and outgoing recoveries
	// A shortcut to set both incoming and outgoing recoveries
	ClusterRoutingAllocationNodeConcurrentRecoveries *float64 `json:"clusterRoutingAllocationNodeConcurrentRecoveries,omitempty" tf:"cluster_routing_allocation_node_concurrent_recoveries,omitempty"`

	// (Number) Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	// Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	ClusterRoutingAllocationNodeInitialPrimariesRecoveries *float64 `json:"clusterRoutingAllocationNodeInitialPrimariesRecoveries,omitempty" tf:"cluster_routing_allocation_node_initial_primaries_recoveries,omitempty"`

	// (Boolean) Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	// Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	ClusterRoutingAllocationSameShardHost *bool `json:"clusterRoutingAllocationSameShardHost,omitempty" tf:"cluster_routing_allocation_same_shard_host,omitempty"`

	// (Number) Maximum number of primary and replica shards allocated to each node
	// Maximum number of primary and replica shards allocated to each node
	ClusterRoutingAllocationTotalShardsPerNode *float64 `json:"clusterRoutingAllocationTotalShardsPerNode,omitempty" tf:"cluster_routing_allocation_total_shards_per_node,omitempty"`

	// (String) Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	// Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	ClusterRoutingRebalanceEnable *string `json:"clusterRoutingRebalanceEnable,omitempty" tf:"cluster_routing_rebalance_enable,omitempty"`

	// (String) The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	// The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	IndicesBreakerFielddataLimit *string `json:"indicesBreakerFielddataLimit,omitempty" tf:"indices_breaker_fielddata_limit,omitempty"`

	// (Number) A constant that all field data estimations are multiplied by
	// A constant that all field data estimations are multiplied by
	IndicesBreakerFielddataOverhead *float64 `json:"indicesBreakerFielddataOverhead,omitempty" tf:"indices_breaker_fielddata_overhead,omitempty"`

	// request data structures (e.g. calculating aggregations) are prevented from exceeding
	// The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
	IndicesBreakerRequestLimit *string `json:"indicesBreakerRequestLimit,omitempty" tf:"indices_breaker_request_limit,omitempty"`

	// (Number) A constant that all request estimations are multiplied by
	// A constant that all request estimations are multiplied by
	IndicesBreakerRequestOverhead *float64 `json:"indicesBreakerRequestOverhead,omitempty" tf:"indices_breaker_request_overhead,omitempty"`

	// (String) The percentage of total amount of memory that can be used across all breakers
	// The percentage of total amount of memory that can be used across all breakers
	IndicesBreakerTotalLimit *string `json:"indicesBreakerTotalLimit,omitempty" tf:"indices_breaker_total_limit,omitempty"`

	// (String) Maximum total inbound and outbound recovery traffic for each node, in mb
	// Maximum total inbound and outbound recovery traffic for each node, in mb
	IndicesRecoveryMaxBytesPerSec *string `json:"indicesRecoveryMaxBytesPerSec,omitempty" tf:"indices_recovery_max_bytes_per_sec,omitempty"`

	// (String) The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	// The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	NetworkBreakerInflightRequestsLimit *string `json:"networkBreakerInflightRequestsLimit,omitempty" tf:"network_breaker_inflight_requests_limit,omitempty"`

	// (Number) A constant that all in flight requests estimations are multiplied by
	// A constant that all in flight requests estimations are multiplied by
	NetworkBreakerInflightRequestsOverhead *float64 `json:"networkBreakerInflightRequestsOverhead,omitempty" tf:"network_breaker_inflight_requests_overhead,omitempty"`

	// (String) Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	// Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	ScriptMaxCompilationsRate *string `json:"scriptMaxCompilationsRate,omitempty" tf:"script_max_compilations_rate,omitempty"`

	// wide default timeout for all search requests
	// A time string setting a cluster-wide default timeout for all search requests
	SearchDefaultSearchTimeout *string `json:"searchDefaultSearchTimeout,omitempty" tf:"search_default_search_timeout,omitempty"`
}

type SettingsObservation struct {

	// (String) Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	// Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	ActionAutoCreateIndex *string `json:"actionAutoCreateIndex,omitempty" tf:"action_auto_create_index,omitempty"`

	// (Boolean) When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	// When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	ActionDestructiveRequiresName *bool `json:"actionDestructiveRequiresName,omitempty" tf:"action_destructive_requires_name,omitempty"`

	// (Boolean) Make the whole cluster read only and metadata is not allowed to be modified
	// Make the whole cluster read only and metadata is not allowed to be modified
	ClusterBlocksReadOnly *bool `json:"clusterBlocksReadOnly,omitempty" tf:"cluster_blocks_read_only,omitempty"`

	// (Boolean) Make the whole cluster read only, but allows to delete indices to free up resources
	// Make the whole cluster read only, but allows to delete indices to free up resources
	ClusterBlocksReadOnlyAllowDelete *bool `json:"clusterBlocksReadOnlyAllowDelete,omitempty" tf:"cluster_blocks_read_only_allow_delete,omitempty"`

	// (Boolean) If false, you cannot close open indices
	// If false, you cannot close open indices
	ClusterIndicesCloseEnable *bool `json:"clusterIndicesCloseEnable,omitempty" tf:"cluster_indices_close_enable,omitempty"`

	// (String) A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	// A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	ClusterInfoUpdateInterval *string `json:"clusterInfoUpdateInterval,omitempty" tf:"cluster_info_update_interval,omitempty"`

	// frozen data nodes; shards for closed indices do not count toward this limit
	// The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
	ClusterMaxShardsPerNode *float64 `json:"clusterMaxShardsPerNode,omitempty" tf:"cluster_max_shards_per_node,omitempty"`

	// (Number) The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	// The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	ClusterMaxShardsPerNodeFrozen *float64 `json:"clusterMaxShardsPerNodeFrozen,omitempty" tf:"cluster_max_shards_per_node_frozen,omitempty"`

	// (String) Specifies which operations are rejected when there is no active master in a cluster (all, write)
	// Specifies which operations are rejected when there is no active master in a cluster (all, write)
	ClusterNoMasterBlock *string `json:"clusterNoMasterBlock,omitempty" tf:"cluster_no_master_block,omitempty"`

	// (String) Whether allocation for persistent tasks is active (all, none)
	// Whether allocation for persistent tasks is active (all, none)
	ClusterPersistentTasksAllocationEnable *string `json:"clusterPersistentTasksAllocationEnable,omitempty" tf:"cluster_persistent_tasks_allocation_enable,omitempty"`

	// (String) A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	// A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	ClusterPersistentTasksAllocationRecheckInterval *string `json:"clusterPersistentTasksAllocationRecheckInterval,omitempty" tf:"cluster_persistent_tasks_allocation_recheck_interval,omitempty"`

	// (String) Specify when shard rebalancing is allowed (always, indices_primaries_active, indices_all_active)
	// Specify when shard rebalancing is allowed (always, indices_primaries_active, indices_all_active)
	ClusterRoutingAllocationAllowRebalance *string `json:"clusterRoutingAllocationAllowRebalance,omitempty" tf:"cluster_routing_allocation_allow_rebalance,omitempty"`

	// (String) Use custom node attributes to take hardware configuration into account when allocating shards
	// Use custom node attributes to take hardware configuration into account when allocating shards
	ClusterRoutingAllocationAwarenessAttributes *string `json:"clusterRoutingAllocationAwarenessAttributes,omitempty" tf:"cluster_routing_allocation_awareness_attributes,omitempty"`

	// (Number) Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	// Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	ClusterRoutingAllocationBalanceIndex *float64 `json:"clusterRoutingAllocationBalanceIndex,omitempty" tf:"cluster_routing_allocation_balance_index,omitempty"`

	// (Number) Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	// Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	ClusterRoutingAllocationBalanceShard *float64 `json:"clusterRoutingAllocationBalanceShard,omitempty" tf:"cluster_routing_allocation_balance_shard,omitempty"`

	// (Number) Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	// Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	ClusterRoutingAllocationBalanceThreshold *float64 `json:"clusterRoutingAllocationBalanceThreshold,omitempty" tf:"cluster_routing_allocation_balance_threshold,omitempty"`

	// (Number) How many concurrent shard rebalances are allowed cluster wide
	// How many concurrent shard rebalances are allowed cluster wide
	ClusterRoutingAllocationClusterConcurrentRebalance *float64 `json:"clusterRoutingAllocationClusterConcurrentRebalance,omitempty" tf:"cluster_routing_allocation_cluster_concurrent_rebalance,omitempty"`

	// (Boolean) Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	// Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	ClusterRoutingAllocationDiskIncludeRelocations *bool `json:"clusterRoutingAllocationDiskIncludeRelocations,omitempty" tf:"cluster_routing_allocation_disk_include_relocations,omitempty"`

	// (Boolean) Whether the disk allocation decider is active
	// Whether the disk allocation decider is active
	ClusterRoutingAllocationDiskThresholdEnabled *bool `json:"clusterRoutingAllocationDiskThresholdEnabled,omitempty" tf:"cluster_routing_allocation_disk_threshold_enabled,omitempty"`

	// (String) Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	// Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	ClusterRoutingAllocationDiskWatermarkHigh *string `json:"clusterRoutingAllocationDiskWatermarkHigh,omitempty" tf:"cluster_routing_allocation_disk_watermark_high,omitempty"`

	// (String) Allocator will not allocate shards to nodes that have more than this percentage disk used
	// Allocator will not allocate shards to nodes that have more than this percentage disk used
	ClusterRoutingAllocationDiskWatermarkLow *string `json:"clusterRoutingAllocationDiskWatermarkLow,omitempty" tf:"cluster_routing_allocation_disk_watermark_low,omitempty"`

	// (String) Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	// Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	ClusterRoutingAllocationEnable *string `json:"clusterRoutingAllocationEnable,omitempty" tf:"cluster_routing_allocation_enable,omitempty"`

	// (Number) How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	// How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentIncomingRecoveries *float64 `json:"clusterRoutingAllocationNodeConcurrentIncomingRecoveries,omitempty" tf:"cluster_routing_allocation_node_concurrent_incoming_recoveries,omitempty"`

	// (Number) How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	// How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries *float64 `json:"clusterRoutingAllocationNodeConcurrentOutgoingRecoveries,omitempty" tf:"cluster_routing_allocation_node_concurrent_outgoing_recoveries,omitempty"`

	// (Number) A shortcut to set both incoming and outgoing recoveries
	// A shortcut to set both incoming and outgoing recoveries
	ClusterRoutingAllocationNodeConcurrentRecoveries *float64 `json:"clusterRoutingAllocationNodeConcurrentRecoveries,omitempty" tf:"cluster_routing_allocation_node_concurrent_recoveries,omitempty"`

	// (Number) Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	// Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	ClusterRoutingAllocationNodeInitialPrimariesRecoveries *float64 `json:"clusterRoutingAllocationNodeInitialPrimariesRecoveries,omitempty" tf:"cluster_routing_allocation_node_initial_primaries_recoveries,omitempty"`

	// (Boolean) Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	// Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	ClusterRoutingAllocationSameShardHost *bool `json:"clusterRoutingAllocationSameShardHost,omitempty" tf:"cluster_routing_allocation_same_shard_host,omitempty"`

	// (Number) Maximum number of primary and replica shards allocated to each node
	// Maximum number of primary and replica shards allocated to each node
	ClusterRoutingAllocationTotalShardsPerNode *float64 `json:"clusterRoutingAllocationTotalShardsPerNode,omitempty" tf:"cluster_routing_allocation_total_shards_per_node,omitempty"`

	// (String) Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	// Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	ClusterRoutingRebalanceEnable *string `json:"clusterRoutingRebalanceEnable,omitempty" tf:"cluster_routing_rebalance_enable,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	// The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	IndicesBreakerFielddataLimit *string `json:"indicesBreakerFielddataLimit,omitempty" tf:"indices_breaker_fielddata_limit,omitempty"`

	// (Number) A constant that all field data estimations are multiplied by
	// A constant that all field data estimations are multiplied by
	IndicesBreakerFielddataOverhead *float64 `json:"indicesBreakerFielddataOverhead,omitempty" tf:"indices_breaker_fielddata_overhead,omitempty"`

	// request data structures (e.g. calculating aggregations) are prevented from exceeding
	// The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
	IndicesBreakerRequestLimit *string `json:"indicesBreakerRequestLimit,omitempty" tf:"indices_breaker_request_limit,omitempty"`

	// (Number) A constant that all request estimations are multiplied by
	// A constant that all request estimations are multiplied by
	IndicesBreakerRequestOverhead *float64 `json:"indicesBreakerRequestOverhead,omitempty" tf:"indices_breaker_request_overhead,omitempty"`

	// (String) The percentage of total amount of memory that can be used across all breakers
	// The percentage of total amount of memory that can be used across all breakers
	IndicesBreakerTotalLimit *string `json:"indicesBreakerTotalLimit,omitempty" tf:"indices_breaker_total_limit,omitempty"`

	// (String) Maximum total inbound and outbound recovery traffic for each node, in mb
	// Maximum total inbound and outbound recovery traffic for each node, in mb
	IndicesRecoveryMaxBytesPerSec *string `json:"indicesRecoveryMaxBytesPerSec,omitempty" tf:"indices_recovery_max_bytes_per_sec,omitempty"`

	// (String) The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	// The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	NetworkBreakerInflightRequestsLimit *string `json:"networkBreakerInflightRequestsLimit,omitempty" tf:"network_breaker_inflight_requests_limit,omitempty"`

	// (Number) A constant that all in flight requests estimations are multiplied by
	// A constant that all in flight requests estimations are multiplied by
	NetworkBreakerInflightRequestsOverhead *float64 `json:"networkBreakerInflightRequestsOverhead,omitempty" tf:"network_breaker_inflight_requests_overhead,omitempty"`

	// (String) Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	// Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	ScriptMaxCompilationsRate *string `json:"scriptMaxCompilationsRate,omitempty" tf:"script_max_compilations_rate,omitempty"`

	// wide default timeout for all search requests
	// A time string setting a cluster-wide default timeout for all search requests
	SearchDefaultSearchTimeout *string `json:"searchDefaultSearchTimeout,omitempty" tf:"search_default_search_timeout,omitempty"`
}

type SettingsParameters struct {

	// (String) Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	// Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	// +kubebuilder:validation:Optional
	ActionAutoCreateIndex *string `json:"actionAutoCreateIndex,omitempty" tf:"action_auto_create_index,omitempty"`

	// (Boolean) When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	// When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	// +kubebuilder:validation:Optional
	ActionDestructiveRequiresName *bool `json:"actionDestructiveRequiresName,omitempty" tf:"action_destructive_requires_name,omitempty"`

	// (Boolean) Make the whole cluster read only and metadata is not allowed to be modified
	// Make the whole cluster read only and metadata is not allowed to be modified
	// +kubebuilder:validation:Optional
	ClusterBlocksReadOnly *bool `json:"clusterBlocksReadOnly,omitempty" tf:"cluster_blocks_read_only,omitempty"`

	// (Boolean) Make the whole cluster read only, but allows to delete indices to free up resources
	// Make the whole cluster read only, but allows to delete indices to free up resources
	// +kubebuilder:validation:Optional
	ClusterBlocksReadOnlyAllowDelete *bool `json:"clusterBlocksReadOnlyAllowDelete,omitempty" tf:"cluster_blocks_read_only_allow_delete,omitempty"`

	// (Boolean) If false, you cannot close open indices
	// If false, you cannot close open indices
	// +kubebuilder:validation:Optional
	ClusterIndicesCloseEnable *bool `json:"clusterIndicesCloseEnable,omitempty" tf:"cluster_indices_close_enable,omitempty"`

	// (String) A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	// A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	// +kubebuilder:validation:Optional
	ClusterInfoUpdateInterval *string `json:"clusterInfoUpdateInterval,omitempty" tf:"cluster_info_update_interval,omitempty"`

	// frozen data nodes; shards for closed indices do not count toward this limit
	// The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
	// +kubebuilder:validation:Optional
	ClusterMaxShardsPerNode *float64 `json:"clusterMaxShardsPerNode,omitempty" tf:"cluster_max_shards_per_node,omitempty"`

	// (Number) The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	// The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	// +kubebuilder:validation:Optional
	ClusterMaxShardsPerNodeFrozen *float64 `json:"clusterMaxShardsPerNodeFrozen,omitempty" tf:"cluster_max_shards_per_node_frozen,omitempty"`

	// (String) Specifies which operations are rejected when there is no active master in a cluster (all, write)
	// Specifies which operations are rejected when there is no active master in a cluster (all, write)
	// +kubebuilder:validation:Optional
	ClusterNoMasterBlock *string `json:"clusterNoMasterBlock,omitempty" tf:"cluster_no_master_block,omitempty"`

	// (String) Whether allocation for persistent tasks is active (all, none)
	// Whether allocation for persistent tasks is active (all, none)
	// +kubebuilder:validation:Optional
	ClusterPersistentTasksAllocationEnable *string `json:"clusterPersistentTasksAllocationEnable,omitempty" tf:"cluster_persistent_tasks_allocation_enable,omitempty"`

	// (String) A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	// A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	// +kubebuilder:validation:Optional
	ClusterPersistentTasksAllocationRecheckInterval *string `json:"clusterPersistentTasksAllocationRecheckInterval,omitempty" tf:"cluster_persistent_tasks_allocation_recheck_interval,omitempty"`

	// (String) Specify when shard rebalancing is allowed (always, indices_primaries_active, indices_all_active)
	// Specify when shard rebalancing is allowed (always, indices_primaries_active, indices_all_active)
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationAllowRebalance *string `json:"clusterRoutingAllocationAllowRebalance,omitempty" tf:"cluster_routing_allocation_allow_rebalance,omitempty"`

	// (String) Use custom node attributes to take hardware configuration into account when allocating shards
	// Use custom node attributes to take hardware configuration into account when allocating shards
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationAwarenessAttributes *string `json:"clusterRoutingAllocationAwarenessAttributes,omitempty" tf:"cluster_routing_allocation_awareness_attributes,omitempty"`

	// (Number) Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	// Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationBalanceIndex *float64 `json:"clusterRoutingAllocationBalanceIndex,omitempty" tf:"cluster_routing_allocation_balance_index,omitempty"`

	// (Number) Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	// Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationBalanceShard *float64 `json:"clusterRoutingAllocationBalanceShard,omitempty" tf:"cluster_routing_allocation_balance_shard,omitempty"`

	// (Number) Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	// Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationBalanceThreshold *float64 `json:"clusterRoutingAllocationBalanceThreshold,omitempty" tf:"cluster_routing_allocation_balance_threshold,omitempty"`

	// (Number) How many concurrent shard rebalances are allowed cluster wide
	// How many concurrent shard rebalances are allowed cluster wide
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationClusterConcurrentRebalance *float64 `json:"clusterRoutingAllocationClusterConcurrentRebalance,omitempty" tf:"cluster_routing_allocation_cluster_concurrent_rebalance,omitempty"`

	// (Boolean) Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	// Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationDiskIncludeRelocations *bool `json:"clusterRoutingAllocationDiskIncludeRelocations,omitempty" tf:"cluster_routing_allocation_disk_include_relocations,omitempty"`

	// (Boolean) Whether the disk allocation decider is active
	// Whether the disk allocation decider is active
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationDiskThresholdEnabled *bool `json:"clusterRoutingAllocationDiskThresholdEnabled,omitempty" tf:"cluster_routing_allocation_disk_threshold_enabled,omitempty"`

	// (String) Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	// Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationDiskWatermarkHigh *string `json:"clusterRoutingAllocationDiskWatermarkHigh,omitempty" tf:"cluster_routing_allocation_disk_watermark_high,omitempty"`

	// (String) Allocator will not allocate shards to nodes that have more than this percentage disk used
	// Allocator will not allocate shards to nodes that have more than this percentage disk used
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationDiskWatermarkLow *string `json:"clusterRoutingAllocationDiskWatermarkLow,omitempty" tf:"cluster_routing_allocation_disk_watermark_low,omitempty"`

	// (String) Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	// Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationEnable *string `json:"clusterRoutingAllocationEnable,omitempty" tf:"cluster_routing_allocation_enable,omitempty"`

	// (Number) How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	// How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationNodeConcurrentIncomingRecoveries *float64 `json:"clusterRoutingAllocationNodeConcurrentIncomingRecoveries,omitempty" tf:"cluster_routing_allocation_node_concurrent_incoming_recoveries,omitempty"`

	// (Number) How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	// How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries *float64 `json:"clusterRoutingAllocationNodeConcurrentOutgoingRecoveries,omitempty" tf:"cluster_routing_allocation_node_concurrent_outgoing_recoveries,omitempty"`

	// (Number) A shortcut to set both incoming and outgoing recoveries
	// A shortcut to set both incoming and outgoing recoveries
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationNodeConcurrentRecoveries *float64 `json:"clusterRoutingAllocationNodeConcurrentRecoveries,omitempty" tf:"cluster_routing_allocation_node_concurrent_recoveries,omitempty"`

	// (Number) Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	// Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationNodeInitialPrimariesRecoveries *float64 `json:"clusterRoutingAllocationNodeInitialPrimariesRecoveries,omitempty" tf:"cluster_routing_allocation_node_initial_primaries_recoveries,omitempty"`

	// (Boolean) Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	// Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationSameShardHost *bool `json:"clusterRoutingAllocationSameShardHost,omitempty" tf:"cluster_routing_allocation_same_shard_host,omitempty"`

	// (Number) Maximum number of primary and replica shards allocated to each node
	// Maximum number of primary and replica shards allocated to each node
	// +kubebuilder:validation:Optional
	ClusterRoutingAllocationTotalShardsPerNode *float64 `json:"clusterRoutingAllocationTotalShardsPerNode,omitempty" tf:"cluster_routing_allocation_total_shards_per_node,omitempty"`

	// (String) Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	// Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	// +kubebuilder:validation:Optional
	ClusterRoutingRebalanceEnable *string `json:"clusterRoutingRebalanceEnable,omitempty" tf:"cluster_routing_rebalance_enable,omitempty"`

	// (String) The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	// The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	// +kubebuilder:validation:Optional
	IndicesBreakerFielddataLimit *string `json:"indicesBreakerFielddataLimit,omitempty" tf:"indices_breaker_fielddata_limit,omitempty"`

	// (Number) A constant that all field data estimations are multiplied by
	// A constant that all field data estimations are multiplied by
	// +kubebuilder:validation:Optional
	IndicesBreakerFielddataOverhead *float64 `json:"indicesBreakerFielddataOverhead,omitempty" tf:"indices_breaker_fielddata_overhead,omitempty"`

	// request data structures (e.g. calculating aggregations) are prevented from exceeding
	// The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
	// +kubebuilder:validation:Optional
	IndicesBreakerRequestLimit *string `json:"indicesBreakerRequestLimit,omitempty" tf:"indices_breaker_request_limit,omitempty"`

	// (Number) A constant that all request estimations are multiplied by
	// A constant that all request estimations are multiplied by
	// +kubebuilder:validation:Optional
	IndicesBreakerRequestOverhead *float64 `json:"indicesBreakerRequestOverhead,omitempty" tf:"indices_breaker_request_overhead,omitempty"`

	// (String) The percentage of total amount of memory that can be used across all breakers
	// The percentage of total amount of memory that can be used across all breakers
	// +kubebuilder:validation:Optional
	IndicesBreakerTotalLimit *string `json:"indicesBreakerTotalLimit,omitempty" tf:"indices_breaker_total_limit,omitempty"`

	// (String) Maximum total inbound and outbound recovery traffic for each node, in mb
	// Maximum total inbound and outbound recovery traffic for each node, in mb
	// +kubebuilder:validation:Optional
	IndicesRecoveryMaxBytesPerSec *string `json:"indicesRecoveryMaxBytesPerSec,omitempty" tf:"indices_recovery_max_bytes_per_sec,omitempty"`

	// (String) The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	// The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	// +kubebuilder:validation:Optional
	NetworkBreakerInflightRequestsLimit *string `json:"networkBreakerInflightRequestsLimit,omitempty" tf:"network_breaker_inflight_requests_limit,omitempty"`

	// (Number) A constant that all in flight requests estimations are multiplied by
	// A constant that all in flight requests estimations are multiplied by
	// +kubebuilder:validation:Optional
	NetworkBreakerInflightRequestsOverhead *float64 `json:"networkBreakerInflightRequestsOverhead,omitempty" tf:"network_breaker_inflight_requests_overhead,omitempty"`

	// (String) Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	// Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	// +kubebuilder:validation:Optional
	ScriptMaxCompilationsRate *string `json:"scriptMaxCompilationsRate,omitempty" tf:"script_max_compilations_rate,omitempty"`

	// wide default timeout for all search requests
	// A time string setting a cluster-wide default timeout for all search requests
	// +kubebuilder:validation:Optional
	SearchDefaultSearchTimeout *string `json:"searchDefaultSearchTimeout,omitempty" tf:"search_default_search_timeout,omitempty"`
}

// SettingsSpec defines the desired state of Settings
type SettingsSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SettingsParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SettingsInitParameters `json:"initProvider,omitempty"`
}

// SettingsStatus defines the observed state of Settings.
type SettingsStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SettingsObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Settings is the Schema for the Settingss API. Manages a cluster's (persistent) settings.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,opensearch}
type Settings struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SettingsSpec   `json:"spec"`
	Status            SettingsStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SettingsList contains a list of Settingss
type SettingsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Settings `json:"items"`
}

// Repository type metadata.
var (
	Settings_Kind             = "Settings"
	Settings_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Settings_Kind}.String()
	Settings_KindAPIVersion   = Settings_Kind + "." + CRDGroupVersion.String()
	Settings_GroupVersionKind = CRDGroupVersion.WithKind(Settings_Kind)
)

func init() {
	SchemeBuilder.Register(&Settings{}, &SettingsList{})
}
