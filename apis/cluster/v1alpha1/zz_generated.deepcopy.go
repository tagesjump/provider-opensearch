//go:build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Settings) DeepCopyInto(out *Settings) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Settings.
func (in *Settings) DeepCopy() *Settings {
	if in == nil {
		return nil
	}
	out := new(Settings)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Settings) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SettingsInitParameters) DeepCopyInto(out *SettingsInitParameters) {
	*out = *in
	if in.ActionAutoCreateIndex != nil {
		in, out := &in.ActionAutoCreateIndex, &out.ActionAutoCreateIndex
		*out = new(string)
		**out = **in
	}
	if in.ActionDestructiveRequiresName != nil {
		in, out := &in.ActionDestructiveRequiresName, &out.ActionDestructiveRequiresName
		*out = new(bool)
		**out = **in
	}
	if in.ClusterBlocksReadOnly != nil {
		in, out := &in.ClusterBlocksReadOnly, &out.ClusterBlocksReadOnly
		*out = new(bool)
		**out = **in
	}
	if in.ClusterBlocksReadOnlyAllowDelete != nil {
		in, out := &in.ClusterBlocksReadOnlyAllowDelete, &out.ClusterBlocksReadOnlyAllowDelete
		*out = new(bool)
		**out = **in
	}
	if in.ClusterIndicesCloseEnable != nil {
		in, out := &in.ClusterIndicesCloseEnable, &out.ClusterIndicesCloseEnable
		*out = new(bool)
		**out = **in
	}
	if in.ClusterInfoUpdateInterval != nil {
		in, out := &in.ClusterInfoUpdateInterval, &out.ClusterInfoUpdateInterval
		*out = new(string)
		**out = **in
	}
	if in.ClusterMaxShardsPerNode != nil {
		in, out := &in.ClusterMaxShardsPerNode, &out.ClusterMaxShardsPerNode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterMaxShardsPerNodeFrozen != nil {
		in, out := &in.ClusterMaxShardsPerNodeFrozen, &out.ClusterMaxShardsPerNodeFrozen
		*out = new(float64)
		**out = **in
	}
	if in.ClusterNoMasterBlock != nil {
		in, out := &in.ClusterNoMasterBlock, &out.ClusterNoMasterBlock
		*out = new(string)
		**out = **in
	}
	if in.ClusterPersistentTasksAllocationEnable != nil {
		in, out := &in.ClusterPersistentTasksAllocationEnable, &out.ClusterPersistentTasksAllocationEnable
		*out = new(string)
		**out = **in
	}
	if in.ClusterPersistentTasksAllocationRecheckInterval != nil {
		in, out := &in.ClusterPersistentTasksAllocationRecheckInterval, &out.ClusterPersistentTasksAllocationRecheckInterval
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationAllowRebalance != nil {
		in, out := &in.ClusterRoutingAllocationAllowRebalance, &out.ClusterRoutingAllocationAllowRebalance
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationAwarenessAttributes != nil {
		in, out := &in.ClusterRoutingAllocationAwarenessAttributes, &out.ClusterRoutingAllocationAwarenessAttributes
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationBalanceIndex != nil {
		in, out := &in.ClusterRoutingAllocationBalanceIndex, &out.ClusterRoutingAllocationBalanceIndex
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationBalanceShard != nil {
		in, out := &in.ClusterRoutingAllocationBalanceShard, &out.ClusterRoutingAllocationBalanceShard
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationBalanceThreshold != nil {
		in, out := &in.ClusterRoutingAllocationBalanceThreshold, &out.ClusterRoutingAllocationBalanceThreshold
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationClusterConcurrentRebalance != nil {
		in, out := &in.ClusterRoutingAllocationClusterConcurrentRebalance, &out.ClusterRoutingAllocationClusterConcurrentRebalance
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskIncludeRelocations != nil {
		in, out := &in.ClusterRoutingAllocationDiskIncludeRelocations, &out.ClusterRoutingAllocationDiskIncludeRelocations
		*out = new(bool)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskThresholdEnabled != nil {
		in, out := &in.ClusterRoutingAllocationDiskThresholdEnabled, &out.ClusterRoutingAllocationDiskThresholdEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskWatermarkHigh != nil {
		in, out := &in.ClusterRoutingAllocationDiskWatermarkHigh, &out.ClusterRoutingAllocationDiskWatermarkHigh
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskWatermarkLow != nil {
		in, out := &in.ClusterRoutingAllocationDiskWatermarkLow, &out.ClusterRoutingAllocationDiskWatermarkLow
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationEnable != nil {
		in, out := &in.ClusterRoutingAllocationEnable, &out.ClusterRoutingAllocationEnable
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries, &out.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries, &out.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeConcurrentRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeConcurrentRecoveries, &out.ClusterRoutingAllocationNodeConcurrentRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeInitialPrimariesRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeInitialPrimariesRecoveries, &out.ClusterRoutingAllocationNodeInitialPrimariesRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationSameShardHost != nil {
		in, out := &in.ClusterRoutingAllocationSameShardHost, &out.ClusterRoutingAllocationSameShardHost
		*out = new(bool)
		**out = **in
	}
	if in.ClusterRoutingAllocationTotalShardsPerNode != nil {
		in, out := &in.ClusterRoutingAllocationTotalShardsPerNode, &out.ClusterRoutingAllocationTotalShardsPerNode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingRebalanceEnable != nil {
		in, out := &in.ClusterRoutingRebalanceEnable, &out.ClusterRoutingRebalanceEnable
		*out = new(string)
		**out = **in
	}
	if in.IndicesBreakerFielddataLimit != nil {
		in, out := &in.IndicesBreakerFielddataLimit, &out.IndicesBreakerFielddataLimit
		*out = new(string)
		**out = **in
	}
	if in.IndicesBreakerFielddataOverhead != nil {
		in, out := &in.IndicesBreakerFielddataOverhead, &out.IndicesBreakerFielddataOverhead
		*out = new(float64)
		**out = **in
	}
	if in.IndicesBreakerRequestLimit != nil {
		in, out := &in.IndicesBreakerRequestLimit, &out.IndicesBreakerRequestLimit
		*out = new(string)
		**out = **in
	}
	if in.IndicesBreakerRequestOverhead != nil {
		in, out := &in.IndicesBreakerRequestOverhead, &out.IndicesBreakerRequestOverhead
		*out = new(float64)
		**out = **in
	}
	if in.IndicesBreakerTotalLimit != nil {
		in, out := &in.IndicesBreakerTotalLimit, &out.IndicesBreakerTotalLimit
		*out = new(string)
		**out = **in
	}
	if in.IndicesRecoveryMaxBytesPerSec != nil {
		in, out := &in.IndicesRecoveryMaxBytesPerSec, &out.IndicesRecoveryMaxBytesPerSec
		*out = new(string)
		**out = **in
	}
	if in.NetworkBreakerInflightRequestsLimit != nil {
		in, out := &in.NetworkBreakerInflightRequestsLimit, &out.NetworkBreakerInflightRequestsLimit
		*out = new(string)
		**out = **in
	}
	if in.NetworkBreakerInflightRequestsOverhead != nil {
		in, out := &in.NetworkBreakerInflightRequestsOverhead, &out.NetworkBreakerInflightRequestsOverhead
		*out = new(float64)
		**out = **in
	}
	if in.ScriptMaxCompilationsRate != nil {
		in, out := &in.ScriptMaxCompilationsRate, &out.ScriptMaxCompilationsRate
		*out = new(string)
		**out = **in
	}
	if in.SearchDefaultSearchTimeout != nil {
		in, out := &in.SearchDefaultSearchTimeout, &out.SearchDefaultSearchTimeout
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SettingsInitParameters.
func (in *SettingsInitParameters) DeepCopy() *SettingsInitParameters {
	if in == nil {
		return nil
	}
	out := new(SettingsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SettingsList) DeepCopyInto(out *SettingsList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Settings, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SettingsList.
func (in *SettingsList) DeepCopy() *SettingsList {
	if in == nil {
		return nil
	}
	out := new(SettingsList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SettingsList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SettingsObservation) DeepCopyInto(out *SettingsObservation) {
	*out = *in
	if in.ActionAutoCreateIndex != nil {
		in, out := &in.ActionAutoCreateIndex, &out.ActionAutoCreateIndex
		*out = new(string)
		**out = **in
	}
	if in.ActionDestructiveRequiresName != nil {
		in, out := &in.ActionDestructiveRequiresName, &out.ActionDestructiveRequiresName
		*out = new(bool)
		**out = **in
	}
	if in.ClusterBlocksReadOnly != nil {
		in, out := &in.ClusterBlocksReadOnly, &out.ClusterBlocksReadOnly
		*out = new(bool)
		**out = **in
	}
	if in.ClusterBlocksReadOnlyAllowDelete != nil {
		in, out := &in.ClusterBlocksReadOnlyAllowDelete, &out.ClusterBlocksReadOnlyAllowDelete
		*out = new(bool)
		**out = **in
	}
	if in.ClusterIndicesCloseEnable != nil {
		in, out := &in.ClusterIndicesCloseEnable, &out.ClusterIndicesCloseEnable
		*out = new(bool)
		**out = **in
	}
	if in.ClusterInfoUpdateInterval != nil {
		in, out := &in.ClusterInfoUpdateInterval, &out.ClusterInfoUpdateInterval
		*out = new(string)
		**out = **in
	}
	if in.ClusterMaxShardsPerNode != nil {
		in, out := &in.ClusterMaxShardsPerNode, &out.ClusterMaxShardsPerNode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterMaxShardsPerNodeFrozen != nil {
		in, out := &in.ClusterMaxShardsPerNodeFrozen, &out.ClusterMaxShardsPerNodeFrozen
		*out = new(float64)
		**out = **in
	}
	if in.ClusterNoMasterBlock != nil {
		in, out := &in.ClusterNoMasterBlock, &out.ClusterNoMasterBlock
		*out = new(string)
		**out = **in
	}
	if in.ClusterPersistentTasksAllocationEnable != nil {
		in, out := &in.ClusterPersistentTasksAllocationEnable, &out.ClusterPersistentTasksAllocationEnable
		*out = new(string)
		**out = **in
	}
	if in.ClusterPersistentTasksAllocationRecheckInterval != nil {
		in, out := &in.ClusterPersistentTasksAllocationRecheckInterval, &out.ClusterPersistentTasksAllocationRecheckInterval
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationAllowRebalance != nil {
		in, out := &in.ClusterRoutingAllocationAllowRebalance, &out.ClusterRoutingAllocationAllowRebalance
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationAwarenessAttributes != nil {
		in, out := &in.ClusterRoutingAllocationAwarenessAttributes, &out.ClusterRoutingAllocationAwarenessAttributes
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationBalanceIndex != nil {
		in, out := &in.ClusterRoutingAllocationBalanceIndex, &out.ClusterRoutingAllocationBalanceIndex
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationBalanceShard != nil {
		in, out := &in.ClusterRoutingAllocationBalanceShard, &out.ClusterRoutingAllocationBalanceShard
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationBalanceThreshold != nil {
		in, out := &in.ClusterRoutingAllocationBalanceThreshold, &out.ClusterRoutingAllocationBalanceThreshold
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationClusterConcurrentRebalance != nil {
		in, out := &in.ClusterRoutingAllocationClusterConcurrentRebalance, &out.ClusterRoutingAllocationClusterConcurrentRebalance
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskIncludeRelocations != nil {
		in, out := &in.ClusterRoutingAllocationDiskIncludeRelocations, &out.ClusterRoutingAllocationDiskIncludeRelocations
		*out = new(bool)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskThresholdEnabled != nil {
		in, out := &in.ClusterRoutingAllocationDiskThresholdEnabled, &out.ClusterRoutingAllocationDiskThresholdEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskWatermarkHigh != nil {
		in, out := &in.ClusterRoutingAllocationDiskWatermarkHigh, &out.ClusterRoutingAllocationDiskWatermarkHigh
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskWatermarkLow != nil {
		in, out := &in.ClusterRoutingAllocationDiskWatermarkLow, &out.ClusterRoutingAllocationDiskWatermarkLow
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationEnable != nil {
		in, out := &in.ClusterRoutingAllocationEnable, &out.ClusterRoutingAllocationEnable
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries, &out.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries, &out.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeConcurrentRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeConcurrentRecoveries, &out.ClusterRoutingAllocationNodeConcurrentRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeInitialPrimariesRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeInitialPrimariesRecoveries, &out.ClusterRoutingAllocationNodeInitialPrimariesRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationSameShardHost != nil {
		in, out := &in.ClusterRoutingAllocationSameShardHost, &out.ClusterRoutingAllocationSameShardHost
		*out = new(bool)
		**out = **in
	}
	if in.ClusterRoutingAllocationTotalShardsPerNode != nil {
		in, out := &in.ClusterRoutingAllocationTotalShardsPerNode, &out.ClusterRoutingAllocationTotalShardsPerNode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingRebalanceEnable != nil {
		in, out := &in.ClusterRoutingRebalanceEnable, &out.ClusterRoutingRebalanceEnable
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IndicesBreakerFielddataLimit != nil {
		in, out := &in.IndicesBreakerFielddataLimit, &out.IndicesBreakerFielddataLimit
		*out = new(string)
		**out = **in
	}
	if in.IndicesBreakerFielddataOverhead != nil {
		in, out := &in.IndicesBreakerFielddataOverhead, &out.IndicesBreakerFielddataOverhead
		*out = new(float64)
		**out = **in
	}
	if in.IndicesBreakerRequestLimit != nil {
		in, out := &in.IndicesBreakerRequestLimit, &out.IndicesBreakerRequestLimit
		*out = new(string)
		**out = **in
	}
	if in.IndicesBreakerRequestOverhead != nil {
		in, out := &in.IndicesBreakerRequestOverhead, &out.IndicesBreakerRequestOverhead
		*out = new(float64)
		**out = **in
	}
	if in.IndicesBreakerTotalLimit != nil {
		in, out := &in.IndicesBreakerTotalLimit, &out.IndicesBreakerTotalLimit
		*out = new(string)
		**out = **in
	}
	if in.IndicesRecoveryMaxBytesPerSec != nil {
		in, out := &in.IndicesRecoveryMaxBytesPerSec, &out.IndicesRecoveryMaxBytesPerSec
		*out = new(string)
		**out = **in
	}
	if in.NetworkBreakerInflightRequestsLimit != nil {
		in, out := &in.NetworkBreakerInflightRequestsLimit, &out.NetworkBreakerInflightRequestsLimit
		*out = new(string)
		**out = **in
	}
	if in.NetworkBreakerInflightRequestsOverhead != nil {
		in, out := &in.NetworkBreakerInflightRequestsOverhead, &out.NetworkBreakerInflightRequestsOverhead
		*out = new(float64)
		**out = **in
	}
	if in.ScriptMaxCompilationsRate != nil {
		in, out := &in.ScriptMaxCompilationsRate, &out.ScriptMaxCompilationsRate
		*out = new(string)
		**out = **in
	}
	if in.SearchDefaultSearchTimeout != nil {
		in, out := &in.SearchDefaultSearchTimeout, &out.SearchDefaultSearchTimeout
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SettingsObservation.
func (in *SettingsObservation) DeepCopy() *SettingsObservation {
	if in == nil {
		return nil
	}
	out := new(SettingsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SettingsParameters) DeepCopyInto(out *SettingsParameters) {
	*out = *in
	if in.ActionAutoCreateIndex != nil {
		in, out := &in.ActionAutoCreateIndex, &out.ActionAutoCreateIndex
		*out = new(string)
		**out = **in
	}
	if in.ActionDestructiveRequiresName != nil {
		in, out := &in.ActionDestructiveRequiresName, &out.ActionDestructiveRequiresName
		*out = new(bool)
		**out = **in
	}
	if in.ClusterBlocksReadOnly != nil {
		in, out := &in.ClusterBlocksReadOnly, &out.ClusterBlocksReadOnly
		*out = new(bool)
		**out = **in
	}
	if in.ClusterBlocksReadOnlyAllowDelete != nil {
		in, out := &in.ClusterBlocksReadOnlyAllowDelete, &out.ClusterBlocksReadOnlyAllowDelete
		*out = new(bool)
		**out = **in
	}
	if in.ClusterIndicesCloseEnable != nil {
		in, out := &in.ClusterIndicesCloseEnable, &out.ClusterIndicesCloseEnable
		*out = new(bool)
		**out = **in
	}
	if in.ClusterInfoUpdateInterval != nil {
		in, out := &in.ClusterInfoUpdateInterval, &out.ClusterInfoUpdateInterval
		*out = new(string)
		**out = **in
	}
	if in.ClusterMaxShardsPerNode != nil {
		in, out := &in.ClusterMaxShardsPerNode, &out.ClusterMaxShardsPerNode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterMaxShardsPerNodeFrozen != nil {
		in, out := &in.ClusterMaxShardsPerNodeFrozen, &out.ClusterMaxShardsPerNodeFrozen
		*out = new(float64)
		**out = **in
	}
	if in.ClusterNoMasterBlock != nil {
		in, out := &in.ClusterNoMasterBlock, &out.ClusterNoMasterBlock
		*out = new(string)
		**out = **in
	}
	if in.ClusterPersistentTasksAllocationEnable != nil {
		in, out := &in.ClusterPersistentTasksAllocationEnable, &out.ClusterPersistentTasksAllocationEnable
		*out = new(string)
		**out = **in
	}
	if in.ClusterPersistentTasksAllocationRecheckInterval != nil {
		in, out := &in.ClusterPersistentTasksAllocationRecheckInterval, &out.ClusterPersistentTasksAllocationRecheckInterval
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationAllowRebalance != nil {
		in, out := &in.ClusterRoutingAllocationAllowRebalance, &out.ClusterRoutingAllocationAllowRebalance
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationAwarenessAttributes != nil {
		in, out := &in.ClusterRoutingAllocationAwarenessAttributes, &out.ClusterRoutingAllocationAwarenessAttributes
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationBalanceIndex != nil {
		in, out := &in.ClusterRoutingAllocationBalanceIndex, &out.ClusterRoutingAllocationBalanceIndex
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationBalanceShard != nil {
		in, out := &in.ClusterRoutingAllocationBalanceShard, &out.ClusterRoutingAllocationBalanceShard
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationBalanceThreshold != nil {
		in, out := &in.ClusterRoutingAllocationBalanceThreshold, &out.ClusterRoutingAllocationBalanceThreshold
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationClusterConcurrentRebalance != nil {
		in, out := &in.ClusterRoutingAllocationClusterConcurrentRebalance, &out.ClusterRoutingAllocationClusterConcurrentRebalance
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskIncludeRelocations != nil {
		in, out := &in.ClusterRoutingAllocationDiskIncludeRelocations, &out.ClusterRoutingAllocationDiskIncludeRelocations
		*out = new(bool)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskThresholdEnabled != nil {
		in, out := &in.ClusterRoutingAllocationDiskThresholdEnabled, &out.ClusterRoutingAllocationDiskThresholdEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskWatermarkHigh != nil {
		in, out := &in.ClusterRoutingAllocationDiskWatermarkHigh, &out.ClusterRoutingAllocationDiskWatermarkHigh
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationDiskWatermarkLow != nil {
		in, out := &in.ClusterRoutingAllocationDiskWatermarkLow, &out.ClusterRoutingAllocationDiskWatermarkLow
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationEnable != nil {
		in, out := &in.ClusterRoutingAllocationEnable, &out.ClusterRoutingAllocationEnable
		*out = new(string)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries, &out.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries, &out.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeConcurrentRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeConcurrentRecoveries, &out.ClusterRoutingAllocationNodeConcurrentRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationNodeInitialPrimariesRecoveries != nil {
		in, out := &in.ClusterRoutingAllocationNodeInitialPrimariesRecoveries, &out.ClusterRoutingAllocationNodeInitialPrimariesRecoveries
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingAllocationSameShardHost != nil {
		in, out := &in.ClusterRoutingAllocationSameShardHost, &out.ClusterRoutingAllocationSameShardHost
		*out = new(bool)
		**out = **in
	}
	if in.ClusterRoutingAllocationTotalShardsPerNode != nil {
		in, out := &in.ClusterRoutingAllocationTotalShardsPerNode, &out.ClusterRoutingAllocationTotalShardsPerNode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterRoutingRebalanceEnable != nil {
		in, out := &in.ClusterRoutingRebalanceEnable, &out.ClusterRoutingRebalanceEnable
		*out = new(string)
		**out = **in
	}
	if in.IndicesBreakerFielddataLimit != nil {
		in, out := &in.IndicesBreakerFielddataLimit, &out.IndicesBreakerFielddataLimit
		*out = new(string)
		**out = **in
	}
	if in.IndicesBreakerFielddataOverhead != nil {
		in, out := &in.IndicesBreakerFielddataOverhead, &out.IndicesBreakerFielddataOverhead
		*out = new(float64)
		**out = **in
	}
	if in.IndicesBreakerRequestLimit != nil {
		in, out := &in.IndicesBreakerRequestLimit, &out.IndicesBreakerRequestLimit
		*out = new(string)
		**out = **in
	}
	if in.IndicesBreakerRequestOverhead != nil {
		in, out := &in.IndicesBreakerRequestOverhead, &out.IndicesBreakerRequestOverhead
		*out = new(float64)
		**out = **in
	}
	if in.IndicesBreakerTotalLimit != nil {
		in, out := &in.IndicesBreakerTotalLimit, &out.IndicesBreakerTotalLimit
		*out = new(string)
		**out = **in
	}
	if in.IndicesRecoveryMaxBytesPerSec != nil {
		in, out := &in.IndicesRecoveryMaxBytesPerSec, &out.IndicesRecoveryMaxBytesPerSec
		*out = new(string)
		**out = **in
	}
	if in.NetworkBreakerInflightRequestsLimit != nil {
		in, out := &in.NetworkBreakerInflightRequestsLimit, &out.NetworkBreakerInflightRequestsLimit
		*out = new(string)
		**out = **in
	}
	if in.NetworkBreakerInflightRequestsOverhead != nil {
		in, out := &in.NetworkBreakerInflightRequestsOverhead, &out.NetworkBreakerInflightRequestsOverhead
		*out = new(float64)
		**out = **in
	}
	if in.ScriptMaxCompilationsRate != nil {
		in, out := &in.ScriptMaxCompilationsRate, &out.ScriptMaxCompilationsRate
		*out = new(string)
		**out = **in
	}
	if in.SearchDefaultSearchTimeout != nil {
		in, out := &in.SearchDefaultSearchTimeout, &out.SearchDefaultSearchTimeout
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SettingsParameters.
func (in *SettingsParameters) DeepCopy() *SettingsParameters {
	if in == nil {
		return nil
	}
	out := new(SettingsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SettingsSpec) DeepCopyInto(out *SettingsSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SettingsSpec.
func (in *SettingsSpec) DeepCopy() *SettingsSpec {
	if in == nil {
		return nil
	}
	out := new(SettingsSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SettingsStatus) DeepCopyInto(out *SettingsStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SettingsStatus.
func (in *SettingsStatus) DeepCopy() *SettingsStatus {
	if in == nil {
		return nil
	}
	out := new(SettingsStatus)
	in.DeepCopyInto(out)
	return out
}
